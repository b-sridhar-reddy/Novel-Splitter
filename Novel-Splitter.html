<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Novel Chapter Splitter (ZIP & EPUB)</title>
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
    integrity="sha512-+S6mdcRvj3e8yoU0u3vTqq7tMqgCydoD4rJ6xLe3rC0tG5x3biv4nhvE60aR1x9n2h2JmLQFhWClQqS7Q3bX0g=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <style>
    :root { color-scheme: dark light; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font: 16px/1.5 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial;
      background: #0b0c10;
      color: #e6edf3;
    }
    .wrap { max-width: 820px; margin: auto; padding: 24px; }
    h1 { font-size: 24px; margin: 0 0 12px; }
    p.lead { opacity: .85; margin: 0 0 16px; }
    .card { background: #11151a; border: 1px solid #1f2630; border-radius: 12px; padding: 16px; }
    label { display:block; margin:8px 0 6px; font-weight:600; }
    input[type="file"], select, input[type="text"] {
      width:100%; display:block; padding:10px; border-radius:8px;
      border:1px solid #26313f; background:#0d1117; color:#e6edf3;
    }
    .row { display:grid; grid-template-columns:1fr; gap:12px; }
    @media(min-width:720px){ .row{ grid-template-columns:1fr 1fr; } }
    .btns { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button {
      appearance:none; border:1px solid #2b3441; background:#0f141b; color:#e6edf3;
      padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer;
    }
    button.primary { background:#1f6feb; border-color:#1f6feb; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .status { margin-top:12px; padding:10px; border-radius:8px; background:#0d1117; border:1px solid #222b36; }
    .status.success { border-color:#1a7f37; }
    .status.error { border-color:#d1242f; }
    .progress { margin-top:12px; background:#0d1117; border:1px solid #222b36; border-radius:8px; overflow:hidden; display:none; }
    .progress .bar { height:10px; width:0%; background:#1f6feb; transition:width .25s ease; }
    .progress .txt { font-size:12px; padding:6px 8px; opacity:.85; }
    .muted { opacity:.7; }
    .small { font-size:12px; }
    .match-preview { margin-top:8px; font-size:12px; color:#9fb7ff; }
    .meta-row { display:flex; gap:8px; margin-top:8px; align-items:center; }
    .meta-row > * { flex:1; }
    .meta-label { font-size:12px; opacity:.8; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ðŸ“– Novel Chapter Splitter</h1>
    <p class="lead">Load a <strong>.txt</strong> novel, optionally add a cover image, choose chapter-detection template (or Auto Detect), then export chapters as a <strong>ZIP</strong> of .txt files or as an <strong>EPUB</strong>. All client-side.</p>

    <div class="card">
      <div class="row">
        <div>
          <label for="fileInput">Novel text file (.txt)</label>
          <input id="fileInput" type="file" accept=".txt,text/plain">
          <div id="fileNameInfo" class="small muted"></div>
        </div>
        <div>
          <label for="coverInput">Optional cover image</label>
          <input id="coverInput" type="file" accept="image/*">
          <div id="coverNameInfo" class="small muted"></div>
        </div>
      </div>

      <div style="margin-top:10px">
        <label for="chapterPattern">Chapter heading format</label>
        <select id="chapterPattern">
          <option value="auto" selected>Auto Detect</option>
          <option value="chinese">Chinese: ç¬¬12ç«  â€¦</option>
          <option value="chapter">English: Chapter 12 â€¦</option>
          <option value="ch">English: Ch. 12 â€¦</option>
          <option value="titledot">Title.Number: æ ‡é¢˜.1 (e.g. ä½œä¸ºæ–°æˆ¿å®¢çš„ç¬¬ä¸€å¤©.1)</option>
          <option value="parenfullwidth">Fullwidth paren: ï¼ˆ1.ï¼‰</option>
        </select>
        <div id="matchPreview" class="match-preview" style="display:none"></div>
      </div>

      <div class="meta-row" style="margin-top:12px">
        <div>
          <label class="meta-label">EPUB metadata (optional)</label>
          <input id="metaTitle" type="text" placeholder="Title (defaults to filename)">
        </div>
        <div>
          <label class="meta-label" style="visibility:hidden">author</label>
          <input id="metaAuthor" type="text" placeholder="Author (optional)">
        </div>
      </div>

      <div class="btns">
        <button id="processZipBtn" class="primary" disabled>Split & Download ZIP</button>
        <button id="processEpubBtn" disabled>Split & Download EPUB</button>
      </div>

      <div id="progressContainer" class="progress">
        <div class="bar" id="progressBar"></div>
        <div class="txt" id="progressText">0%</div>
      </div>

      <div id="status" class="status small">Waiting for a .txt fileâ€¦</div>
      <div class="small muted" style="margin-top:8px">Note: filenames inside ZIP/EPUB are zero-padded (000_, 001_, â€¦) so they sort correctly.</div>
    </div>
  </div>

<script>
'use strict';

// DOM refs
const fileInput = document.getElementById('fileInput');
const coverInput = document.getElementById('coverInput');
const chapterPatternSelect = document.getElementById('chapterPattern');
const fileNameInfo = document.getElementById('fileNameInfo');
const coverNameInfo = document.getElementById('coverNameInfo');
const processZipBtn = document.getElementById('processZipBtn');
const processEpubBtn = document.getElementById('processEpubBtn');
const progressContainer = document.getElementById('progressContainer');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');
const statusDiv = document.getElementById('status');
const matchPreview = document.getElementById('matchPreview');
const metaTitle = document.getElementById('metaTitle');
const metaAuthor = document.getElementById('metaAuthor');

// State
let fileContent = '';
let fileName = '';
let coverFile = null;

// Helpers
function setStatus(msg, type){
  statusDiv.textContent = msg;
  statusDiv.classList.remove('success','error');
  if(type) statusDiv.classList.add(type);
}
function showProgress(){ progressContainer.style.display = 'block'; updateProgress(0,''); }
function hideProgress(){ progressContainer.style.display = 'none'; }
function updateProgress(pct, msg){
  const v = Math.max(0, Math.min(100, Math.round(pct)));
  progressBar.style.width = v + '%';
  progressText.textContent = v + '%' + (msg ? (' â€“ ' + msg) : '');
}
function safeFilename(name){
  return String(name || '')
    .replace(/[\u0000-\u001f]/g, '')
    .replace(/[\\\/:*?"<>|]/g, '')
    .replace(/\s+/g, '_')
    .slice(0, 180) || 'untitled';
}
function readFileAsText(file){
  return new Promise((res, rej) => {
    const r = new FileReader();
    r.onload = () => res(String(r.result || ''));
    r.onerror = rej;
    r.readAsText(file);
  });
}
function readFileAsArrayBuffer(file){
  return new Promise((res, rej) => {
    const r = new FileReader();
    r.onload = () => res(r.result);
    r.onerror = rej;
    r.readAsArrayBuffer(file);
  });
}
function downloadFile(blob, filename){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(a.href), 1500);
}
function uuidv4(){
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}
function escapeHtml(s){
  const d = document.createElement('div');
  d.innerText = s;
  return d.innerHTML;
}
function getCoverExtension(mime){
  const map = {'image/jpeg':'jpg','image/jpg':'jpg','image/png':'png','image/gif':'gif','image/webp':'webp','image/svg+xml':'svg'};
  return map[mime] || 'img';
}

// Chapter detection templates
const CHAPTER_TEMPLATES = {
  chinese: /^\s*ç¬¬\s*([0-9]+)\s*ç« [\.ã€‚:\s]?.*$/i,
  chapter: /^\s*Chapter\s*([0-9]+)\b.*$/i,
  ch: /^\s*Ch(?:apter)?\.?\s*([0-9]+)\b.*$/i,
  titledot: /^\s*([^\r\n]{1,120})\.\s*\d+\s*$/u,           // e.g. ä½œä¸ºæ–°æˆ¿å®¢çš„ç¬¬ä¸€å¤©.1
  parenfullwidth: /^\s*ï¼ˆ\s*\d+\s*\.?\s*ï¼‰\s*$/u         // e.g. ï¼ˆ1.ï¼‰
};

// detect which template appears more than once in first chunk
function detectPattern(lines){
  for(const key in CHAPTER_TEMPLATES){
    const rx = CHAPTER_TEMPLATES[key];
    let c = 0;
    for(let i=0;i<Math.min(lines.length, 400); i++){
      if(rx.test(lines[i])){ c++; if(c>1) return {key, rx}; }
    }
  }
  return null;
}

// show match preview for selected template (first few matches)
function showMatchPreviewForSelection(text){
  if(!text){ matchPreview.style.display = 'none'; return; }
  const lines = text.split(/\r?\n/);
  const selected = chapterPatternSelect.value;
  if(selected === 'auto'){
    const d = detectPattern(lines);
    if(d){
      matchPreview.style.display = 'block';
      matchPreview.textContent = `Auto-detected template: ${d.key}. Example matches: ${getExampleMatches(d.rx, lines).join(' | ')}`;
    } else {
      matchPreview.style.display = 'block';
      matchPreview.textContent = 'Auto-detect found no repeated heading pattern in first 400 lines.';
    }
  } else {
    const rx = CHAPTER_TEMPLATES[selected];
    if(!rx){ matchPreview.style.display = 'none'; return; }
    const matches = getExampleMatches(rx, lines);
    matchPreview.style.display = 'block';
    matchPreview.textContent = matches.length ? `Matches: ${matches.join(' | ')}` : 'No matches found for this template in the first 500 lines.';
  }
}
function getExampleMatches(rx, lines){
  const arr = [];
  for(let i=0;i<Math.min(lines.length, 500); i++){
    if(rx.test(lines[i])) arr.push(lines[i].trim());
    if(arr.length>=5) break;
  }
  return arr;
}

// splitting logic
function splitChapters(text){
  const lines = String(text).split(/\r?\n/);
  const selected = chapterPatternSelect.value;
  const headingInfo = (selected === 'auto') ? detectPattern(lines) : { key: selected, rx: CHAPTER_TEMPLATES[selected] || null };
  const rx = headingInfo ? headingInfo.rx : null;

  // preview update
  if(headingInfo && headingInfo.rx){
    const examples = getExampleMatches(headingInfo.rx, lines);
    if(examples.length){
      matchPreview.style.display = 'block';
      matchPreview.textContent = `Using ${headingInfo.key}: ${examples.slice(0,3).join(' | ')}`;
    } else {
      matchPreview.style.display = 'block';
      matchPreview.textContent = `Using ${headingInfo.key}: no early matches found.`;
    }
  } else {
    matchPreview.style.display = 'none';
  }

  const chapters = [];
  let current = null;
  const pushCurrent = () => { if(current) chapters.push(current); };

  if(!rx){
    // no heading pattern: entire text as single entry
    chapters.push({ title: 'synopsis', content: text.trim() });
    return chapters;
  }

  let preface = [];
  for(const raw of lines){
    const line = String(raw || '');
    const m = line.match(rx);
    if(m){
      pushCurrent();
      current = { title: line.trim(), content: '' };
    } else {
      if(!current) preface.push(line);
      else current.content += line + '\n';
    }
  }
  pushCurrent();
  chapters.unshift({ title: 'synopsis', content: preface.join('\n').trim() });
  return chapters;
}

// build XHTML for EPUB chapter
function buildXhtml(title, bodyText){
  const paras = String(bodyText || '').split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  const body = paras.map(p => `<p>${escapeHtml(p)}</p>`).join('\n');
  return `<?xml version="1.0" encoding="utf-8"?>\n<!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh">\n<head>\n  <meta charset="utf-8" />\n  <title>${escapeHtml(title || '')}</title>\n</head>\n<body>\n  <h2>${escapeHtml(title || '')}</h2>\n  ${body}\n</body>\n</html>`;
}

// ZIP creation with indexed filenames
async function createZipDownload(chapters){
  showProgress();
  updateProgress(5, 'Preparing ZIPâ€¦');
  const zip = new JSZip();
  const base = safeFilename((fileName || 'novel').replace(/\.txt$/i, ''));
  const total = chapters.length;
  for(let i=0;i<total;i++){
    const ch = chapters[i];
    const namePart = (i === 0) ? 'synopsis' : (ch.title || `chapter${i}`);
    const index = String(i).padStart(3, '0');
    const fname = `${index}_${safeFilename(namePart)}.txt`;
    zip.file(fname, ch.content || '');
    updateProgress(10 + (i/total)*80, `Adding ${fname}`);
    // yield for UI responsiveness
    await new Promise(r => setTimeout(r, 0));
  }
  updateProgress(95, 'Generating ZIPâ€¦');
  const blob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 } });
  const outName = `${base}_chapters.zip`;
  downloadFile(blob, outName);
  updateProgress(100, 'Done');
  hideProgress();
  setStatus(`Downloaded ${outName}`, 'success');
}

// EPUB creation with indexed filenames
async function createEpubDownload(chapters){
  showProgress();
  updateProgress(5, 'Preparing EPUBâ€¦');
  const zip = new JSZip();
  const base = safeFilename((fileName || 'novel').replace(/\.txt$/i, ''));
  const bookId = uuidv4();
  const titleMeta = metaTitle.value.trim() || base;
  const authorMeta = metaAuthor.value.trim() || 'Unknown';
  const lang = 'zh';

  // mimetype first and stored (no compression)
  zip.file('mimetype', 'application/epub+zip', { compression: 'STORE' });

  // META-INF/container.xml
  zip.file('META-INF/container.xml',
    `<?xml version="1.0" encoding="UTF-8"?>\n` +
    `<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">\n` +
    `  <rootfiles>\n` +
    `    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>\n` +
    `  </rootfiles>\n` +
    `</container>`
  );

  const oebps = zip.folder('OEBPS');

  // optional cover image
  let coverHref = null;
  if(coverFile){
    const ext = getCoverExtension(coverFile.type);
    const ab = await readFileAsArrayBuffer(coverFile);
    const coverName = `cover.${ext}`;
    oebps.file(coverName, ab);
    coverHref = coverName;
  }

  // create XHTML files with indexed filenames
  const xhtmlFiles = [];
  for(let i=0;i<chapters.length;i++){
    const ch = chapters[i];
    const namePart = (i === 0) ? 'synopsis' : (ch.title || `chapter${i}`);
    const index = String(i).padStart(3, '0');
    const fname = `${index}_${safeFilename(namePart)}.xhtml`;
    const xhtml = buildXhtml(ch.title, ch.content);
    oebps.file(fname, xhtml);
    xhtmlFiles.push({ id: `chap${i}`, href: fname, title: ch.title || `Chapter ${i}` });
    updateProgress(10 + (i / chapters.length) * 70, `Adding ${fname}`);
    await new Promise(r => setTimeout(r, 0));
  }

  // optional cover.xhtml (kept as cover.xhtml so readers can detect it)
  if(coverHref){
    const coverXhtml = `<?xml version="1.0" encoding="utf-8"?>\n<!DOCTYPE html>\n<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="${lang}" lang="${lang}">\n<head><meta charset="utf-8"/><title>Cover</title></head>\n<body style="margin:0;padding:0;text-align:center;">\n  <img src="${coverHref}" alt="Cover" style="max-width:100%;height:auto;"/>\n</body>\n</html>`;
    oebps.file('cover.xhtml', coverXhtml);
  }

  // toc.ncx
  const navMapEntries = xhtmlFiles.map((f, idx) =>
    `<navPoint id="navPoint-${idx+1}" playOrder="${idx+1}">\n  <navLabel><text>${escapeHtml(f.title)}</text></navLabel>\n  <content src="${f.href}"/>\n</navPoint>`
  ).join('\n');
  oebps.file('toc.ncx',
    `<?xml version="1.0" encoding="UTF-8"?>\n` +
    `<!DOCTYPE ncx PUBLIC "-//NISO//DTD ncx 2005-1//EN" "http://www.daisy.org/z3986/2005/ncx-2005-1.dtd">\n` +
    `<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">\n` +
    `  <head>\n    <meta name="dtb:uid" content="${bookId}"/>\n    <meta name="dtb:depth" content="1"/>\n    <meta name="dtb:totalPageCount" content="0"/>\n    <meta name="dtb:maxPageNumber" content="0"/>\n` +
    `  </head>\n` +
    `  <docTitle><text>${escapeHtml(titleMeta)}</text></docTitle>\n` +
    `  <navMap>\n${navMapEntries}\n  </navMap>\n` +
    `</ncx>`
  );

  // content.opf
  const manifestItems = [];
  const spineItems = [];

  manifestItems.push(`<item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>`);

  if(coverHref){
    manifestItems.push(`<item id="cover-image" href="${coverHref}" media-type="${coverFile.type || 'image/jpeg'}"/>`);
    manifestItems.push(`<item id="cover" href="cover.xhtml" media-type="application/xhtml+xml"/>`);
    spineItems.push(`<itemref idref="cover" linear="yes"/>`);
  }

  for(const f of xhtmlFiles){
    manifestItems.push(`<item id="${f.id}" href="${f.href}" media-type="application/xhtml+xml"/>`);
    spineItems.push(`<itemref idref="${f.id}" linear="yes"/>`);
  }

  const opf = `<?xml version="1.0" encoding="utf-8"?>\n` +
    `<package xmlns="http://www.idpf.org/2007/opf" version="2.0" unique-identifier="BookId">\n` +
    `  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf">\n` +
    `    <dc:title>${escapeHtml(titleMeta)}</dc:title>\n` +
    `    <dc:creator>${escapeHtml(authorMeta)}</dc:creator>\n` +
    `    <dc:language>${lang}</dc:language>\n` +
    `    <dc:identifier id="BookId">urn:uuid:${bookId}</dc:identifier>\n` +
    (coverHref ? `    <meta name="cover" content="cover-image"/>\n` : '') +
    `  </metadata>\n` +
    `  <manifest>\n    ${manifestItems.join('\n    ')}\n  </manifest>\n` +
    `  <spine toc="ncx">\n    ${spineItems.join('\n    ')}\n  </spine>\n` +
    `</package>`;

  oebps.file('content.opf', opf);

  updateProgress(95, 'Packaging EPUBâ€¦');
  const blob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 } });
  const outName = `${base}.epub`;
  downloadFile(blob, outName);
  updateProgress(100, 'Done');
  hideProgress();
  setStatus(`Downloaded ${outName}`, 'success');
}

// Event handlers
fileInput.addEventListener('change', async (e) => {
  const f = e.target.files && e.target.files[0];
  if(!f){ setStatus('No file selected', 'error'); return; }
  if(!(f.type === 'text/plain' || /\.txt$/i.test(f.name))){
    setStatus('Please choose a .txt file.', 'error');
    return;
  }
  try{
    showProgress();
    updateProgress(5, 'Reading fileâ€¦');
    fileContent = await readFileAsText(f);
    fileName = f.name || 'novel.txt';
    fileNameInfo.textContent = `Loaded: ${fileName}`;
    setStatus(`Loaded: ${fileName}`, 'success');
    processZipBtn.disabled = false;
    processEpubBtn.disabled = false;
    // show match preview
    showMatchPreviewForSelection(fileContent);
    updateProgress(100, 'Ready');
    setTimeout(hideProgress, 300);
  }catch(err){
    console.error(err);
    hideProgress();
    setStatus('Failed to read file.', 'error');
  }
});

coverInput.addEventListener('change', (e) => {
  coverFile = e.target.files && e.target.files[0] ? e.target.files[0] : null;
  if(coverFile){
    if(!String(coverFile.type || '').startsWith('image/')){
      setStatus('Cover must be an image file.', 'error');
      coverFile = null;
      coverNameInfo.textContent = '';
      return;
    }
    coverNameInfo.textContent = `Cover: ${coverFile.name}`;
    setStatus(`Cover loaded: ${coverFile.name}`, 'success');
  } else {
    coverNameInfo.textContent = '';
  }
});

chapterPatternSelect.addEventListener('change', () => {
  if(fileContent) showMatchPreviewForSelection(fileContent);
});

processZipBtn.addEventListener('click', async () => {
  if(!fileContent){ setStatus('Select a .txt file first.', 'error'); return; }
  setStatus('Processing ZIPâ€¦');
  try{
    const chapters = splitChapters(fileContent);
    await createZipDownload(chapters);
  }catch(err){
    console.error(err);
    setStatus('Error creating ZIP.', 'error');
  }
});

processEpubBtn.addEventListener('click', async () => {
  if(!fileContent){ setStatus('Select a .txt file first.', 'error'); return; }
  setStatus('Processing EPUBâ€¦');
  try{
    const chapters = splitChapters(fileContent);
    await createEpubDownload(chapters);
  }catch(err){
    console.error(err);
    setStatus('Error creating EPUB.', 'error');
  }
});
</script>
</body>
</html>
